# Lecture 2

**Agenda:**

* Real software products are engineered
* Software Engineering Practices
* Software Life-Cycle Models
* UML
* System Engineering
* Requirements Engineering

### Software Product Size

* **Windows Vista:** 50 million lines of code
* **Windows XP:** 40 million LOC
* **Red Hat Linux v7.1:** 30 million LOC
* **Mac OS X 10.4:** 86 million LOC
* **Debian 5.0 / GNU Linux:** 324 million LOC
* **Android OS:** 12 million LOC
* **Mercedes-Benz Navigation:** 20 million LOC
* **F-22 Fighter Jet:** 1.7 million LOC
* **Boeing 787:** 6.5 million LOC

Not all code is created equal

### Software Engineering Practice

Practice is a broad array of concepts, principles, methods, and tools. The things you'll need to actually build high-quality computer software.

The essense of software engineering practice:

* Understand the problem (communication and analysis)
* Plan a solution (modeling and software design)
* Carry out the plan (code generation)
* Example the result for accuracy (testing and QA)

### Core Software Engineering Principles

* Provide value to the customer and the user
* Keep it simple
* Maintain the product and project vision
* Others will use what you produce
* Be open to the future
* Plan ahead for reuse
* Think!


## Software Engineering Practices

For each step in the framework we will identify underlying principles, how to initiate the practice, and an abbreviated task list.

* Communication
* Planning
* Modeling
* Construction
* Deployment

### Communication Practices

**Principles:**

* Listen
* Prepare before you communicate
* Facilitate the communcation
* Face-to-face is best
* Take notes and document decisions
* Collaborate with the customer
* Stay focused
* Draw pictures when things are unclear
* Negotiation works best when both parties win

**Initiation:**

* The parties should be physically close to one another
* Make sure communication in interactice
* Create solid team ecosystems
* Use the right team structure

**Task List:**

* Identify who it is you need to speak with
* Define the best mechanism for communication
* Establish overall goals and objectives and define the scope
* Have stakeholders define scenarios for usage
* Extract major functions and features
* Review the results with all stakeholders

### Planning Practices

**Principles:**

* Understand the project scope
* Involve the customer (and other stakeholders)
* Recognize that planning is iterative
* Estimate based on what you know
* Consider risk
* Be realistic
* Adjust granularity as you plan
* Define how quality will be achieved
* Define how you'll accommodate changes
* Track what you've planned

**Initiation:**

* Why is the system being developed?
* What will be done?
* When will it be accomplished?
* Who is responsible?
* Where are they located (organizationally)?
* How will the job be done technically and managerially?
* How much of each resource is needed?

**Task List:**

* Re-assess project scope
* Assess risks
* Evaluate functions/features
* Consider infrastructure functions/features
* Create rough plan
  * Number of software increments
  * Overall schedule
  * Delivery dates for increments
* Create fine plan for first increment
* Track progress

### Modeling Practices

**Analysis models** represent the customer requirements. The **Design models** represent characteristics of the software that help practitioners construct it effectively.

#### Analysis Modeling Practices

* Represent the information domain
* Represent the software functions
* Represent the software behavior
* Move from essence towards implementation

Elements of the Analysis model:

* Data Model
* Flow Model
* Class Model
* Behavior Model

#### Design Modeling Practices

**Principles:**

* Design must be traceable to analysis model
* Always consider architecture
* Focus on the design of data
* Interfaces must be designed
* Components should exhibit functional independence
* Components should be loosely coupled
* Design representation should be easily understood
* The design model should be developed iterativly

Elements of the design model:

* Data design
* Architectural design
* Component design
* Interface design

### Construction Practices

Before you write one line of code, you should:

* Understand the problem you are trying to solve
* Understand basic design principles and concepts
* Pick a programming language that meets the needs of the software and the environment.
* Select a programming environment that will make your job easier
* Create unit tests that will be applied when the code is complete

**Coding Principles:**

* Constrain your algorithms by following structured programming practices.
* Select data structures that will meet the needs of the design.
* Understand software architecture and interfaces
* Keep conditional logic as simple as possible
* Create nested loops in a way that makes them easily testable
* Select meaningful variable names
* Follow local coding standards
* Write code that is self-documenting
* Create a visual layout using indentation and blank lines that aids understanding

After completing a first pass of the code, be sure to:

* Conduct a code walkthrough when appropriate
* Preform unit tests and fix errors
* Refactor the code

**Testing Principles:**

* All tests should be traceable to requirements
* Tests should be planned
* Testing begins "in the small" and moves towards "in the large"
* Exhaustive testing is not possible

**Deployment Principles:**

* Manage customer expectation for each increment
* A complete delivery package should be assembled and tested
* Instructional materials must be provided to end-users
* Buggy software should be fixed first, delivered later

### Questions during process:

* Where do I start?
* When do I need to talk to the customer?
* What requirements do I need to gather?
* Do I need to think about analysis/design?
* How do I prioritize requirements?
* How do I deal with complexity?

Left off on slide 30, sort of confusing 20-30 slides after this.
